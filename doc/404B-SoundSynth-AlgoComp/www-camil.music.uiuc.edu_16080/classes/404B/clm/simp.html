<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN""http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<!-- Mirrored from www-camil.music.uiuc.edu:16080/classes/404B/clm/simp.html by HTTrack Website Copier/3.x [XR&CO'2005], Thu, 26 Jan 2006 16:40:55 GMT -->
<head>  <meta content="text/html; charset=iso-8859-1" http-equiv="content-type"/>  <style media="all" type="text/css">@import "../css/cm.css";  </style>  <title>320A: Software Sound Synthesis</title></head><body><!-- <div id="header"><div id="logo"><img title="" alt="[img/cmlogosw.png]" height="50" width="50" src="img/cmlogosw.png"/></div></div>--><div id="content"><h1>An Introduction to CLM</h1><p>CLM (Common Lisp Music) is a audio synthesis language written in Lispand C. <ul><li><a href="http://ccrma.stanford.edu/software/clm/">CLM Home Page</a></li><li><a href="clm-3/clm.html">CLM Documentation</a></li><li><a href="clm-3/clm.html#definstrument">Example Instruments</a></li><li><a href="clm-3/ins.txt">Instruments by Category</a><li><a href="clm-3/index.html">Source Code</a></ul></p><h2>Quick Tour</h2><p> To work with CLM you first load it into Lisp, then compile andload CLM instrument definitions, and then call the instruments togenerate sound.<p><h4>Loading the CLM system</h4><p>To install CLM into the current Lisp image, load the file "all.lisp"located in the CLM distribution directory on your machine:</p><blockquote><pre>(load <span class="string">"/path/to/clm-3/all"</span>) <span class="comment">; fix for your machine</span></pre></blockquote><h4>Compiling and Loading CLM instruments</h4><p>CLM instruments are typically saved in lisp text files with a".ins" filename extension.  These files must be compiled and loadedinto Lisp before attempting to use the instrument.</p><p>Copy <a href="simp.ins">simp.ins</a> into your home directory.</p><p>Compile and load the "simp.ins" instrument file into lisp:</p><blockquote><pre>(cd )(cload <span class="string">"simp.ins"</span>)</pre></blockquote><h4>Generating Sound</h4><p>CLM instruments are Lisp functions. To generate sound, call the instrument inside the <code>with-sound</code> macro:</p><blockquote><pre>(with-sound ()  (simp 0 1 440 .5))(with-sound (<span class="keyword">:srate</span> 44100 <span class="keyword">:channels</span> 2 <span class="keyword">:output</span> <span class="string">"hiho.aiff"</span>)  (loop for x from 0 to 4 by .25        do (simp x (pick .5 1 2) (between 220 880) .1)))</pre></blockquote><p>A CLM instrument is a specialized Lisp function that computes digital audiosamples. It does not return values back to the caller. Hereis what the simp instrument definition looks like:</p><!-- Example 1 --><div id="simp" class="float" id="simp"><p class="captxt"><span class="floatlabel">Example 1.</span>  A simple CLM instrument definition.</p><pre>(<span class="special">defparameter</span> <span class="defined">*simpenv*</span> '(0 0 .25 1 .75 1 1 0))(<span class="special">definstrument</span> <span class="defined">simp</span> (start dur freq amp &optional (ampenv *simpenv*))  (<span class="special">let*</span> ((beg (seconds-&gt;samples start))         (end (+ beg (seconds-&gt;samples dur)))         (osc (make-oscil <span class="keyword">:frequency</span> freq))         (env (make-env <span class="keyword">:envelope</span> ampenv <span class="keyword">:scaler</span> amp                         <span class="keyword">:duration</span> dur)))    (run      (<span class="special">loop</span> for i from beg to end            do           (outa i (* (env env) (oscil osc))))))</pre></div><h2>The <code>definstrument</code> macro</h2><p>Instrument functions are defined withCLM's <code>definstrument</code> macro rather than Lisp's <code>defun</code> form.  Recall that a function definitionin Lisp consists of three parts: the <em>name</em> of the function,its <em>lambda parameter list</em> and its <em>body</em>. Thesecorrespond to a <code>definstrument</code> expression as follows:</p><blockquote><p><code>(definsrument</code> <em>name</em> <code>( </code>{<em>param</em>}*<code> )</code> {<em>body</em>}* )</p></blockquote><h3>Instrument names</h3><p>The first argument to <code>definstrument</code> is the name of theinstrument.  As with all function names, choose a symbol that providessome useful information to the caller, for example it might describethe type of sound or synthesis method that the instrumentrepresents. In our example the name <code>simp</code> (line 0) waschosen to indicate that the definition is a very simple example of aCLM instrument.</p><h3>Instrument parameters</h3><p>After the name of the instrument comes a list of zero ormore <em>lambda parameter definitions</em>. The parameters of an audioinstrument serve the same purpose as in a regular Lisp function: theyare the "windows" through which the function receives its inputvalues.  In the case of CLM instruments, these input values usuallycontrol some aspect of the sound that the instrument generates. Forexample, the parameters that our <code>simp</code> instrument declareson line 0 have the following meaning:</p><dl><dt><code>start </code>{<var>number</var>}</dt><dd>The start time of the sound in seconds.</dd><dt><code>dur </code>{<var>number</var>}</dt><dd>The duration of the sound in seconds.</dd><dt><code>freq </code>{<var>number</var>}</dt><dd>The frequency of the sound in Hertz.</dd><dt><code>amp </code>{<var>number</var>}</dt><dd>The maximum logical amplitude of the sound, 0&lt;<var>number</var>&lt;1.0.</dd><dt><code>ampenv </code>{<var>list</var>}</dt><dd>An <em>envelope list</em> that defines how <var>amp</var> changes overthe duration of the sound. The list consists of alternating <var>x</var>and <var>y</var> values where each <var>x</var>  is a percentage(0-100) of <var>dur</var> and each <var>y</var> is a scaler (0-1)on <var>amp</var>.</dd></dl><h3>Instrument body</h3><p>The body of the function defines the code that is evaluated when theinstrument is called. A typical instrument definition has (up to)three parts to its body:</p><ol><li><em>Initialization code</em> sets up, or configures, the instrument sothat it can generate sound. Binding local variables and allocatingunit generators are two very common initialization tasks performed byinstruments.<!-- Two types of initializationsare commonly found in instrument definitions:<ol>  <li>    Local variable declarations. Instrument variables typically hold    two types of values:    <ol>      <li>         control variables whose values have been mapped from the         external parameter values into a representation used by         the synthesis algorithm.      </li>      <li>        state variables that contain <em>unit generators</em>, or        sound processors such as oscillators and envelopes used by the        synthesis algorithm to generate sound.      </li>    </ol>  </li>  <li> <em>I/O</em>    (input/output) statements that open or initialize input files used    by the algorithm in then calculation of its output sound.</li></ol>--></li><li><em>Runtime code</em> generates the output audio signal.  Iteratingon a sample-by-sample basis to generate sound output is one verycommon runtime task.</li><li><em>Finalization code</em> may perform "cleanup" actions after theinstrument has generated sound. Finalizations are not so commonlyfound in instrument definitions because it not necessary to deallocateunit generators by hand -- these are automatically <em>garbagecollected</em> by Lisp once the instrument stops.<!-- Closing open input files is onefinialization action that sound file processing instruments perform.Note that is is usually not necessary to <em>deallocate</em> unitgenerators by hand as these are automatically <em>garbagecollected</em> by Lisp once the instrument is returns. --></li></ol><p>The following diagram shows one particular "template" that is commonto many different CLM instrument definitions:</p><blockquote><p><code>(definstrument </code><var>name</var> <code>( </code>{<var>param</var>}*<code> )</code><br/><code>&nbsp;&nbsp;(let* ( </code><spanstyle="color:blue;">{<em>variable initializations</em>}*</span><code>)</code><br/><code>&nbsp;&nbsp;&nbsp;&nbsp;(run </code><span style="color:blue;">{<em>runtime statements</em>}*</span><code> ))</code><br/><!-- ode>&nbsp;&nbsp;</code><span style="color:blue;">{<em>io finalization}*</span></em><code> )</code><br/ --></blockquote><p>Of the three type of statements -- initialization, runtime andfinalization -- only the runtime statements are explicitly marked assuch in the instrument definition. Runtime code is easy to spot becauseit is always enclosed inside CLM's special <code>run</code> macro.The job of <code>run</code> is compile the sample-by-samplecalculation of the output audio signal as fast and efficient aspossible. Once the runtime statements have been identified theinstrument's initialization and finalization code (if any) can belocated by their proximate positions before and afterthe <code>run</code> macro in the body of the instrument.</p><h2>The <code>simp</code> instrument explained</h2><p>The <code>simp</code> instrument (shown again here in Example 2)clearly follows the instrument template outlined above.<p><!-- Example 2 --><div id="simp" class="float" id="simp2"><p class="captxt"><span class="floatlabel">Example 2.</span>  Simp with functional  links to CLM documentation.</p><pre class="code">  (<span class="special">defparameter</span> <span class="defined">*simpenv*</span> '(0 0 .25 1 .75 1 1 0))<span style="font:serif; color:silver">0</span> (<a href="clm-3/clm.html#definstrument">definstrument</a> <span class="defined">simp</span> (start dur freq amp &optional (ampenv *simpenv*))<span style="font:serif; color:silver">1</span>   (<span class="special">let*</span> ((beg (<a href="clm-3/clm.html#seconds->samples">seconds-&gt;samples</a> start))<span style="font:serif; color:silver">2</span>          (end (+ beg (<a href="clm-3/clm.html#seconds->samples">seconds-&gt;samples</a> dur)))<span style="font:serif; color:silver">3</span>          (osc (<a href="clm-3/clm.html#make-oscil">make-oscil</a> <span class="keyword">:frequency</span> freq))<span style="font:serif; color:silver">4</span>          (env (<a href="clm-3/clm.html#make-env">make-env</a> <span class="keyword">:envelope</span> ampenv <span class="keyword">:scaler</span> amp <span style="font:serif; color:silver">5</span>                         <span class="keyword">:duration</span> dur)))<span style="font:serif; color:silver">6</span>     (<a href="clm-3/clm.html#run">run</a><span style="font:serif; color:silver">7</span>      (<span class="special">loop</span> for i from beg to end <span style="font:serif; color:silver">8</span>            do<span style="font:serif; color:silver">9</span>            (<a href="clm-3/clm.html#outa">outa</a> i (* (<a href="clm-3/clm.html#env">env</a> env) (<a href="clm-3/clm.html#oscil">oscil</a> osc)))))))</pre></div><p>Lines 1-5 contain <code>simp</code>'s initialization code.The <code>let*</code> declaration binds and initializes four localvariables.  Recall that Lisp's special <code>let*</code> form is justlike <code>let</code> except that its variables are bound insequential order such that variable bindings can reference earlierbindings within the same declaration. In the case of <code>simp</code>the variable <var>end</var> depends on the value of the <var>beg</var>variable that is bound directly before it. The first twovariables <var>beg</var> and <var>end</var> hold the starting andending positions of the sound samples that <code>simp</code> willgenerate to the output audio stream.  The <var>osc</var>and <var>env</var> variables hold unit generators that the instrumentuses to generate sound.</p><p>Lines 6-9 define <code>simp</code>'s runtime code, i.e. the statementsthat actually produce the sound.  The runtime statement consists of aloop expression that iterates from the a startingposition <var>beg</var> to and ending position <var>end</var> that weredetermined by mapping the time and dur parameters to sample positionsusing the CLM function <code>seconds-&gt;samples</code>. For eachsample position <var>i</var>, <code>simp</code> calculates a soundsample by multiplying the output of an oscillator <var>osc</var> by theoutput of an amplitude envelope <var>env</var>.CLM's <code>outa</code> function then outputs the scaled sample tothe <var>i</var>'th sample position of channel a in the audio stream.</p><h2>Compiling and Loading Instruments</h2> <p>Once an instrument has been defined in a .ins lisp file it must becompiled and loaded into Lisp before you can begin to work withit. <em>Compilation</em> is a process in which Lisp expression aretransformed into machine instructions that execute many times fasterthan text forms that are interpreted (evaluated) by Lispread-eval-print loop.  CLM instruments <u>must</u> be compiled becausegenerating sound is such a computationally intensive activity.  Forexample, in order to generate CD quality sound our <code>simp</code>instrument must execute its <code>outa</code> runtime statement 44100times for <em>each second</em> of sound it generates!If <code>simp</code> were able to generate stereo files then it wouldhave to generate 88200 samples per second of sound, or 5,292,000samples each minute.</p><p>A compiled file is simply an efficient <em>substitute</em> for a lisptext file. This has two important consequences for the user: </P<ul><li>A compiled file contains a <em>binary</em> representation of Lisp thatshould not be viewed or edited in Emacs!</em></li><li>You must recompile a binary file whenever its source code changes orelse the compiled version will not contain the latest changes.</li></ul><p>Once an instrument file has been compiled its binary (compiled)version can be <em>loaded</em> into Lisp. Loading is very similar toLisp evaluation except that expressions are read from a file ratherthan being typed into the Lisp Listener. Binary files as well assource file can be loaded into Lisp using the <code>load</code>function.  Remember that each time you start Common Music you mustload in your compiled CLM instruments before begin to work with them.Moreover, if you recompile an instrument file then you must alsoreload it or else you will not be working with the latest version ofthe instrument.</p><p>The process of compiling and loading the <code>simp</code> instrumentis shown here in Example 3:</p><!-- Example 3 --><div class="float"><p class="captxt">Example 3. Compiling and loading <a href="simp.ins">simp.ins</a>from the user's home directory.</p><pre class="shell">? <span class="input">(cd)</span>"/Users/hkt/"? <span class="input">(compile-file "simp.ins")</span>"/User/hkt/simp.dfsl"? <span class="input">(load "simp.dfsl")</span>"/User/hkt/simp.dfsl"</pre></div><p>Both <code>compile-file</code> and <code>load</code> allow file namesto include directory components it is possible to compile/load aninstrument from any directory on your machine. But Example 3demonstrates one easy way to work with CLM instruments: usethe <code>(cd)</code> function to change to the instrument's directoryand then compile and load the instrument file(s) into Lisp using justthen name of the file. Using the <code>cd</code> function will let youcut down on the amount of typing (and typos) when compiling and loadinginstrument files.</p><h2>Generating sound</h2> <p>Once an instrument has been compiled and loaded into Lisp you canstart using it to generate music. The easiest way to create soundoutput is to used CLM's <code>with-sound</code> macro to create asound file:</p><!-- Example 4 --><div class="float"><p class="captxt">Example 4. Generating sound with simp.</p><pre class="shell">? <span class="input">(with-sound () (simp 0 1 440 .1 '(0 0 25 1 75 1 100 0)))</span>"test.snd"</pre></div><p>The <code>with-sound</code> macro sets up a "context" for generatingsound files and uses the following general syntax:</p><blockquote><code>(with-sound ( </code>{<var>:option value</var>}*<code> ) </code> {<var>body</var>}*<code> )</code></blockquote><p>The first argument to <code>with-sound</code> is a list of zero ormore keyword <em>sound file options</em> that affect the type of soundfile it will generate. <code>with-sound</code> has many differentoptions, here are the most common ones you will work with. </p><dl><dt><code class="keyword">:output</code> {<var>file</var>}<dd>Specifies the pathname of the output sound file.</dd><dt><code class="keyword">:srate</code> {<var>number</var>}<dd>Specifies the sampling rate of the output sound file.  Defaults to thevalue of <code>*clm-srate*</code>, normally 22050.</dd><dt><code class="keyword">:channels</code> {<var>number</var>}<dd>Specifies the number of audio channels in the output sound file.Defaults to the value of <code>*clm-channels*</code>, normally 1.</dd></dl><p>Consult the <a href="clm-3/clm.html#with-sound"><cod>with-sound</code>documentation</a> for more information.</p><p>Following the options list comes the <em>body</em> of the<code>with-sound</code> macro. The body can contain any number of Lispexpressions but one or more of them should be actual CLM instrumentcalls that generate sound:</p><!-- Example 5 --><div class="float"><p class="captxt">Example 5. Generating sound from a loop.</p><pre class="shell">? <span class="input">(with-sound (:output "/tmp/doinks.aiff" :srate 44100)    (loop with env = '(0 0 1 1 20 .2 100 0)          repeat 20          for x from 0 by .1          do (simp x .2 (between 220 440) (vary .5 .1) env)))</span>"/tmp/doinks.aiff"</pre></div><h3>Playing sound files</h3><p>You can use CLM's <code>dac</code> function to play a sound file thathas already been computed. If you do not specify a file to playthen <code>dac</code> will play the last file written.</p><!-- Example 6 --><div class="float"><p class="captxt">Example 6. Playing sound files with <code>dac</code>.</p><pre class="shell">? <span class="input">(dac)</span>"/tmp/doinks.aiff"? <span class="input">(dac "test.aiff")</span>"test.aiff"</pre></div><h2>The CLM Instrument Distribution</h2> <p>The CLM installation directory contains a large number of exampleinstruments that demonstrate most of the synthesis andsound-processing techniques ever invented. The easiest way to becomefamiliar with the CLM instrument library is to peruse the<a href="clm-3/clm.html#definstrument">Table of CLM instruments</a>and the <a href="clm-3/ins.txt">ins</a> file.</p></div><hr/></body>
<!-- Mirrored from www-camil.music.uiuc.edu:16080/classes/404B/clm/simp.html by HTTrack Website Copier/3.x [XR&CO'2005], Thu, 26 Jan 2006 16:40:55 GMT -->
</html>